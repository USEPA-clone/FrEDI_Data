---
title: "FrEDI State Mental Health"
author: "Industrial Economics, Inc."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  rmarkdown::html_document:
    theme: spacelab
    toc: true
    toc_float: true
    code_folding: hide
---

```{=html}
<style>
/* Simplified version of Bootstrap's responsive table CSS */
.table-responsive {
display: block;
width: 100%;
overflow-x: auto;
}

.table-responsive > table {
width: 100%;
}
</style>
```

```{r knitr setup, include=FALSE}
### The following parameters declare the options for compiling the Markdown document.
knitr::opts_chunk$set(
  include = T,     ### Evaluate and depict outputs of code chunks in the compiled document
  echo    = T,     ### Echo the commands of the code chunks in the compiled document
  message = FALSE, ### Don't include command-line messages output from evaluating code chunks
  cache   = FALSE, ### Don't cache the evaluation of code chunks
  warning = FALSE, ### Don't include warnings from evaluating code chunks
  table.format = "html" 
)
```

```{r load packages, echo = F}
library(tidyverse)
library(readxl)
```

## Set up workspace

### Set Paths

```{r set paths}
# set relative file paths and create lists of input files
projPath      <- getwd()
dataPath      <- projPath %>% file.path("extdata")
codePath      <- projPath %>% file.path("code")
outPath       <- projPath %>% file.path("outputs")
today         <- format(Sys.Date(), "%Y%m%d")
files         <- list.files(dataPath)
future_files  <- files %>% grep("FUTURE", ., value = T)
present_files <- files %>% grep("PRESENT", ., value = T)
```

### Code & custom functions

```{r load code}
for(code_i in list.files(codePath, pattern=".R", full.names = T)){source(code_i)}
```

### Set constants

```{r set constants}
# toggle whether to save intermediate and final files
int_saveFiles <- FALSE
saveFiles <- TRUE
```

### Read in data

The study authors provided degree-binned impact data under RCP 8.5 with the dimension GCM – degree – county – age bin – population – baseline rate – additional cases for scenarios with and without population growth.

```{r read in data}
# loop through FUTURE files, filter to just the HIF we'll use (AVERAGE), and save the data in a df
mh_future_df <- data.frame()
for (i in future_files){
  df_i <- dataPath %>% file.path(i) %>%
          read.csv(header = T) %>%
          filter(HIF == "AVERAGE")
  mh_future_df <- rbind(mh_future_df, df_i)
}

# repeat for PRESENT files
mh_present_df <- data.frame()
for (i in present_files){
  df_i <- dataPath %>% file.path(i) %>%
          read.csv(header = T) %>%
          filter(HIF == "AVERAGE")
  mh_present_df <- rbind(mh_present_df, df_i)
}

# read in state naming crosswalk
state_crosswalk <- file.path(dataPath, "State Crosswalk.xlsx") %>% read_xlsx(sheet = "States")
```

```{r trim and save intermediate data}
# trim dfs to just the columns we'll use
mh_future_df <- mh_future_df %>% select(c(1:11)) %>% left_join(state_crosswalk, by = c("ST" = "ST_postal"))
mh_present_df <- mh_present_df %>% select(c(1:11)) %>% left_join(state_crosswalk, by = c("ST" = "ST_postal"))

# save files
if (int_saveFiles){
  mh_future_df %>% write.csv(file.path(outPath, "Mental Health Future.csv"), row.names = F)
  mh_present_df %>% write.csv(file.path(outPath, "Mental Health Present.csv"), row.names = F)
}
```

## Process data

### Calculate FrEDI impact inputs

We use the static population scenario for rate calculation and then apply scaling factors to account for demographic changes as described below. The authors provided a distribution of impact results, but for this version of FrEDI, we relied on point estimates rather than the results of the Monte Carlo simulation. To calculate the rate of future climate-attributable suicide incidence, we first sum the additional case counts and populations across age bins at the county level. We then aggregate to the state level. Finally, we divide the case count by population for each state to arrive at degree-binned future marginal incidence rates.

```{r FrEDI impacts}
mh_present_df_fredi <- mh_present_df %>%
  aggregate(cbind(CASES_PT, POP_SIZE) ~ ST + DEGREE + MODEL, data = ., FUN = sum) %>%
  mutate(value = CASES_PT / POP_SIZE) %>%
  left_join(state_crosswalk, by = c("ST" = "ST_postal")) %>%
  select(c(ST_full, ST, DEGREE, MODEL, value)) %>%
  mutate(sector = "MentalHealth",
         modelUnitValue = case_when(
           DEGREE == "D1" ~ 1,
           DEGREE == "D2" ~ 2,
           DEGREE == "D3" ~ 3,
           DEGREE == "D4" ~ 4,
           DEGREE == "D5" ~ 5,
           DEGREE == "D6" ~ 6,
           .default = NA
           ),
         impactYear = NA,
         variant = NA,
         impactType = NA
         ) %>%
  select(-DEGREE) %>%
  rename(model = MODEL,
         state = ST_full,
         postal = ST)

mh_present_df_fredi %>% write.csv(file.path(outPath, "MentalHealth_scaledimpacts.csv"), row.names = F)
```

```{r impacts qc check}
all(mh_present_df_fredi$state %in% state_crosswalk$ST_full) && all(state_crosswalk$ST_full %in% mh_present_df_fredi$state)
```

### Calculate scalars

For both the static and dynamic population scenarios provided by the authors, we calculate total incidence at the county level by multiplying the baseline rate by the population, adding the climate-attributable additional cases, and summing across age bins. We then sum case counts and populations to the state level and divide the total case count by population for each state to arrive at degree-binned total incidence rates.

```{r calculate incidence}
# add column for base incidence and total incidence
mh_future_df  <- mh_future_df %>%
  mutate(base_inc = (IR100K/1e5) * POP_SIZE) %>%
  mutate(tot_inc = base_inc + CASES_PT)
mh_present_df <- mh_present_df %>%
  mutate(base_inc = (IR100K/1e5) * POP_SIZE) %>%
  mutate(tot_inc = base_inc + CASES_PT)
```

```{r aggregate to state}
mh_present_df_statesum <- mh_present_df %>%
  aggregate(cbind(tot_inc, POP_SIZE) ~ ST + DEGREE + MODEL + YEAR_CLIM + YEAR_POP, data = ., FUN = sum) %>%
  mutate(pres_inc_rate = (tot_inc / POP_SIZE) * 1e5)

mh_future_df_statesum <- mh_future_df %>%
  aggregate(cbind(tot_inc, POP_SIZE) ~ ST + DEGREE + MODEL + YEAR_CLIM + YEAR_POP, data = ., FUN = sum) %>%
  mutate(fut_inc_rate = (tot_inc / POP_SIZE) * 1e5)
```

#### Population Slice Factor

Because these rates are calculated based only on the population age 5 and older while the FrEDI population input is assumed to include people of all ages, we calculate a set of scalars representing the ratio of these two populations using the ICLUSv2 projections which form the basis for both the FrEDI default scenario and the Belova et al. (2022) analysis.

```{r MH_popSliceAdj scalar}
FrEDI_pops <- dataPath %>% file.path("ICLUS_v2_UN_Probabilistic_Median.xlsx") %>%
  read_xlsx(sheet = "ICLUS_Multiplier")

mh_pop_multiplier_df <- mh_future_df_statesum %>% left_join(FrEDI_pops, by = c("ST" = "ST_postal", "YEAR_POP" = "Year")) %>%
  mutate(value = POP_SIZE/FrEDI_pop) %>%
  select(c(ST_full, ST, YEAR_POP, value)) %>%
  distinct %>%
  mutate(scalarName = "MH_popSliceAdj") %>%
  rename(state = ST_full,
         postal = ST,
         year = YEAR_POP)

if (saveFiles){
  mh_pop_multiplier_df %>% write.csv(file.path(outPath, "Scalar_physAdj_MH_popSliceAdj.csv"), row.names = F)
}
```

Because this scalar represents the proportion of the population that is 5 and older, it should always be less than 1.

```{r MH_popSliceAdj qc check}
all(mh_pop_multiplier_df$state %in% state_crosswalk$ST_full) && all(state_crosswalk$ST_full %in% mh_pop_multiplier_df$state)
sum(mh_pop_multiplier_df$value >= 1) == 0
```

#### Demographic Adjustment Factor

The mortality projections from Belova et al. (2022) represent composite rates aggregated across age bins, and the underlying analysis includes implicit assumptions about how the relative weights of these age bins (and their corresponding incidence rates) change over time. We calculate an additional set of scalars to account for these demographic changes. We take the ratio of the dynamic population scenario rate to static population scenario rate. Population is the only driver that varies between these two scenarios, so the ratio of the two represents the effect of demographic change on projected incidence rates.

```{r MH_popDemoAdj scalar}
states <- unique(mh_future_df_statesum$ST)
future_df <- mh_future_df_statesum %>% select(c(ST, MODEL, YEAR_CLIM, fut_inc_rate))
present_df <- mh_present_df_statesum %>% select(c(ST, MODEL, YEAR_CLIM, pres_inc_rate))
all_state_df <- data.frame()
for (i in states){
  state_present_df <- present_df %>% filter(ST == i)
  state_future_df <- future_df %>% filter(ST == i)
  state_df <- state_present_df %>% left_join(state_future_df) %>% mutate(value = fut_inc_rate / pres_inc_rate)
  state_df_final <- state_df %>% aggregate(value ~ ST + YEAR_CLIM, data = ., FUN = mean)
  all_state_df <- rbind(all_state_df, state_df_final)
}
all_state_df <- all_state_df %>%
  left_join(state_crosswalk, by = c("ST" = "ST_postal")) %>%
  select(c(ST_full, ST, YEAR_CLIM, value)) %>%
  mutate(scalarName = "MH_popDemoAdj") %>%
  rename(state = ST_full,
         postal = ST,
         year = YEAR_CLIM)

if (saveFiles){
  all_state_df %>% write.csv(file.path(outPath, "Scalar_damageAdj_MH_popDemoAdj.csv"), row.names = F)
}
```

```{r MH_popDemoAdj qc check}
all(all_state_df$state %in% state_crosswalk$ST_full) && all(state_crosswalk$ST_full %in% all_state_df$state)
```